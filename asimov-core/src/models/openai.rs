use std::sync::Arc;

use async_openai::{
    types::{
        ChatCompletionRequestUserMessageArgs, CreateChatCompletionRequestArgs,
        CreateEmbeddingRequestArgs,
    },
    Client,
};
use async_stream::stream;
use async_trait::async_trait;
use futures::StreamExt;
use serde::{de::DeserializeOwned, Deserialize};
use typed_builder::TypedBuilder;

use crate::{
    error::Result,
    io::{Input, RawString, StreamedOutput},
    tokenizers::openai::OpenAiTiktoken,
    AsimovError,
};

use super::capabilities::{Embed, Generate};
use crate::io::{JsonStream, TokenStream};

#[derive(TypedBuilder, Clone)]
pub struct OpenAiLlm {
    #[builder(default = "gpt-3.5-turbo".to_string())]
    /// Model name. See the [OpenAI docs](https://platform.openai.com/docs/guides/text-generation)
    model: String,
    #[builder(default, setter(strip_option))]
    /// Stop after `max_tokens` tokens
    max_tokens: Option<u16>,
    #[builder(default, setter(strip_option))]
    /// Stopping criterion: stop generation upon detected sequence
    stop: Option<String>,
    #[builder(default, setter(strip_option))]
    /// Stopping criterion: stop generation upon detected sequence
    temperature: Option<f32>,
}

impl Default for OpenAiLlm {
    fn default() -> Self {
        Self {
            model: "gpt-3.5-turbo".to_string(),
            max_tokens: Default::default(),
            stop: Default::default(),
            temperature: Default::default(),
        }
    }
}

impl OpenAiLlm {
    /// Generate a request to the LLM
    fn request(&self, input: impl Input) -> Result<CreateChatCompletionRequestArgs> {
        let prompt = input.render()?;

        let message = ChatCompletionRequestUserMessageArgs::default()
            .content(prompt)
            .build()?
            .into();

        let mut request = CreateChatCompletionRequestArgs::default();

        request
            .model(&self.model.to_string())
            .n(1)
            .messages([message]);

        if let Some(stop) = &self.stop {
            request.stop(stop);
        }
        if let Some(max_tokens) = self.max_tokens {
            request.max_tokens(max_tokens);
        }
        if let Some(temperature) = self.temperature {
            request.temperature(temperature);
        }

        Ok(request)
    }

    /// Use the model to generate a `String` response.
    async fn raw_string(&self, input: impl Input) -> Result<String> {
        let client = Client::new();

        let request = self.request(input)?.build()?;

        let response = client.chat().create(request).await?;

        let result = response
            .choices
            .into_iter()
            .nth(0)
            .ok_or_else(|| AsimovError::Output("No choices returned from OpenAI".to_string()))?
            .message
            .content
            .ok_or_else(|| {
                AsimovError::Output("No content in the choice returned from OpenAI".to_string())
            })?;

        Ok(result)
    }

    /// Create a stream over the tokens generated by the LLM.
    /// This is the building block for streaming responses.
    async fn stream_tokens(&self, input: impl Input) -> Result<TokenStream> {
        let client = Client::new();
        let request = self.request(input)?.build()?;

        let mut stream = client.chat().create_stream(request).await?;

        let s = stream! {
            while let Some(chunk) = stream.next().await {
                let choice = chunk.unwrap().choices.into_iter().nth(0).unwrap();
                let content = choice.delta.content;

                if let Some(text) = content {
                    yield text
                }
            }
        };

        Ok(TokenStream::new(s))
    }
}

#[async_trait]
impl<S> Generate<S> for OpenAiLlm
where
    for<'a> S: Deserialize<'a>,
{
    /// Implementation for any `Deserialize` type.
    ///
    /// Note: if using `String` as the expected output,
    /// the routine will expect the llm's result to be
    /// surrounded by quotation marks.
    ///
    /// To generate "raw" strings, use the [`RawString`] type
    /// instead.
    async fn generate(&self, input: impl Input) -> Result<S> {
        let raw = self.raw_string(input).await?;
        let parsed = serde_json::from_str(&raw)?;
        Ok(parsed)
    }
}

#[async_trait]
impl Generate<RawString> for OpenAiLlm {
    /// Pass the output of the LLM directly.
    async fn generate(&self, input: impl Input) -> Result<RawString> {
        let raw = self.raw_string(input).await?;
        Ok(RawString::new(raw))
    }
}

#[async_trait]
impl Generate<TokenStream> for OpenAiLlm {
    /// Stream the tokens generated by the LLM directly.
    async fn generate(&self, input: impl Input) -> Result<TokenStream> {
        self.stream_tokens(input).await
    }
}

#[async_trait]
impl<D: DeserializeOwned + Send + 'static> Generate<StreamedOutput<D>> for OpenAiLlm {
    /// Use `json_stream` to stream any type that implements
    /// [`Deserialize`].
    async fn generate(&self, input: impl Input) -> Result<StreamedOutput<D>> {
        let stream = self.stream_tokens(input).await?;
        let stream = stream.map(|t| Ok(t.into_bytes()));
        let stream = JsonStream::<D>::new(Box::pin(stream));

        Ok(StreamedOutput::<D>::new(stream))
    }
}

#[async_trait]
impl Generate<StreamedOutput<RawString>> for OpenAiLlm {
    /// Generate a stream of tokens. Note that because of the fallibility
    /// of the parsing operation inherent to the streaming routine,
    /// the stream will yield a `Result` of [`RawString`].
    ///
    /// That's arguably awkward since there's no actual parsing going on â€“
    /// and probably not what you want.
    ///
    /// Consider using [`TokenStream`] as the result type, since it will
    /// stream tokens, as [`String`], directly.
    async fn generate(&self, input: impl Input) -> Result<StreamedOutput<RawString>> {
        let stream = self.stream_tokens(input).await?;
        let stream = StreamedOutput::<RawString>::new(stream.map(|t| Ok(RawString::new(t))));
        Ok(stream)
    }
}

/// Struct handling the interaction with OpenAI's API for embedding text.
#[derive(TypedBuilder, Clone)]
pub struct OpenAiEmbedding {
    #[builder(default = "text-embedding-ada-002".to_string())]
    model: String,
}

impl Default for OpenAiEmbedding {
    fn default() -> Self {
        Self {
            model: "text-embedding-ada-002".to_string(),
        }
    }
}

#[async_trait]
impl Embed for OpenAiEmbedding {
    type Tokenizer = OpenAiTiktoken;
    const DIM: u32 = 1536;

    /// Embed any type that implement the [`Input`] trait.
    async fn embed<I: Input + ?Sized>(&self, input: &I) -> Result<Vec<f32>> {
        let prompt = input.render()?;

        let client = Client::new();

        let request = CreateEmbeddingRequestArgs::default()
            .model(&self.model.to_string())
            .input(prompt)
            .build()?;

        let response = client.embeddings().create(request).await?;

        let embedding = response.data.into_iter().nth(0).unwrap();

        Ok(embedding.embedding)
    }
}

#[async_trait]
impl<T> Embed for Arc<T>
where
    T: Embed + Sync + Send,
{
    type Tokenizer = OpenAiTiktoken;
    const DIM: u32 = 1536;
    async fn embed<I: Input + ?Sized>(&self, input: &I) -> Result<Vec<f32>> {
        (**self).embed(input).await
    }
}

#[cfg(test)]
mod tests {

    use super::*;
    use crate::{lines, prompt, tokenizers::Tokenizer};
    use serde::{Deserialize, Serialize};

    #[tokio::test]
    async fn test_embedding() -> Result<()> {
        std::env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY must be set");

        let ada002 = OpenAiEmbedding::default();
        let embedding = ada002.embed(&"This is a test".to_string()).await?;
        assert_eq!(embedding.len(), 1536);
        Ok(())
    }
    #[tokio::test]

    async fn test_string_generation() -> Result<()> {
        std::env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY must be set");

        let gpt35 = OpenAiLlm::default();
        let response: RawString = gpt35.generate("How are you doing").await?;
        Ok(())
    }

    #[derive(Deserialize, Debug, PartialEq)]
    struct MyType {
        test: u8,
    }

    #[derive(Serialize, Deserialize, Debug, PartialEq)]
    struct PropertyBag {
        name: String,
        age: u8,
        address: String,
    }

    impl Input for PropertyBag {
        fn render(&self) -> Result<String> {
            Ok(serde_json::to_string(self)?)
        }
    }

    #[derive(Serialize, Deserialize, Debug, PartialEq)]
    struct PythonCode {
        code: String,
    }

    impl Input for PythonCode {
        fn render(&self) -> Result<String> {
            Ok(serde_json::to_string(self)?)
        }
    }

    #[tokio::test]
    async fn test_json_generation() -> Result<()> {
        std::env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY must be set");

        let gpt35 = OpenAiLlm::builder().temperature(0.0).build();
        let response: MyType = gpt35
            .generate(r#"Output the following, verbatim: {"test": 1}"#)
            .await?;
        assert_eq!(response, MyType { test: 1 });
        Ok(())
    }

    #[tokio::test]
    async fn test_stream() -> Result<()> {
        std::env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY must be set");

        let gpt35 = OpenAiLlm::builder().build();
        let mut s: TokenStream = gpt35.generate("How are you doing").await?;

        while let Some(item) = s.next().await {
            println!("{item}");
        }

        Ok(())
    }

    #[tokio::test]
    async fn test_json_stream_generation() -> Result<()> {
        std::env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY must be set");

        let gpt35 = OpenAiLlm::builder().temperature(0.0).build();
        let mut s: StreamedOutput<MyType> = gpt35
            .generate(
                r#"Output the following twice, separated by a new line, verbatim: {"test": 1}"#,
            )
            .await?;

        while let Some(item) = s.next().await {
            let item = item.unwrap();
            assert_eq!(item, MyType { test: 1 });
            println!("{item:?}");
        }

        Ok(())
    }

    #[tokio::test]
    async fn test_json_stream_multiple_items() -> Result<()> {
        std::env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY must be set");
        let gpt4 = OpenAiLlm::builder()
            .temperature(0.0)
            .model("gpt-4".to_string())
            .build();

        let sample = PropertyBag {
            name: "John Doe".to_string(),
            age: 42,
            address: "1234 Main St".to_string(),
        };

        let prompt = prompt!(
            lines! {
                "Output the following thrice separated by a new line, verbatim: {{sample}}"
            },
            sample
        );

        let mut stream: StreamedOutput<PropertyBag> = gpt4.generate(prompt).await?;
        while let Some(item) = stream.next().await {
            let item = item.unwrap();
            println!("The item is {:?}", item);
        }
        Ok(())
    }

    #[tokio::test]
    async fn test_json_stream_single_item() -> Result<()> {
        std::env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY must be set");
        let gpt4 = OpenAiLlm::builder()
            .temperature(0.0)
            .model("gpt-4".to_string())
            .build();

        let sample = PythonCode { code: "import pandas as pd\nimport pyarrow as pa\nfrom statsmodels.tsa.arima.model import ARIMA\nasync def run(tbl_id, output_id):\n    table = await get_table(tbl_id)\n    df = table.value\n    # Assuming 'df' has columns ['date', 'value'] and 'date' is already the index\n    # If 'date' is not the index, uncomment the next line\n    # df.set_index('date', inplace=True)\n    model = ARIMA(df['value'], order=(5,1,0))\n    model_fit = model.fit()\n    forecast = model_fit.forecast(steps=1)\n    result = pd.DataFrame({'forecast': forecast}, index=[df.index[-1] + pd.Timedelta(days=1)])\n    table = pa.Table.from_pandas(result)\n    output = table.to_batches()\n    await ingest_artifact(PyTable(output_id, 1, output))\n    return output_id".to_string() };

        let prompt = prompt!(
            lines! {
                "Output the following, verbatim: {{sample}}"
            },
            sample
        );

        let mut stream: StreamedOutput<PythonCode> = gpt4.generate(prompt).await?;
        while let Some(item) = stream.next().await {
            let item = item.unwrap();
            println!("The item is {:?}", item);
        }
        Ok(())
    }

    #[tokio::test]
    async fn test_token_stream_client_buffer() -> Result<()> {
        std::env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY must be set");

        let gpt4 = OpenAiLlm::builder().model("gpt-4".to_string()).build();

        let sample = PythonCode {
            code: "import numpy as np\nx = np.array([1, 2, 3])\nprint(x)".to_string(),
        };

        let prompt = prompt!(
            lines! {
                "Output the following, verbatim: {{sample}}"
            },
            sample
        );

        let mut token_stream: TokenStream = gpt4.generate(prompt).await?;
        let mut full_text = String::new();

        while let Some(token) = token_stream.next().await {
            println!("Token: {:?}", token);
            full_text.push_str(&token);
        }

        let deserialized: PythonCode = serde_json::from_str(&full_text)?;
        assert_eq!(deserialized, sample);

        println!("Deserialized PythonCode: {:?}", deserialized);

        Ok(())
    }

    #[tokio::test]
    async fn test_token_stream_client_buffer_efficient() -> Result<()> {
        std::env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY must be set");

        let gpt4 = OpenAiLlm::builder().model("gpt-4".to_string()).build();

        let sample = PythonCode {
            code: "import numpy as np\nx = np.array([1, 2, 3])\nprint(x)".to_string(),
        };

        let prompt = prompt!(
            lines! {
                "Output the following, verbatim: {{sample}}"
            },
            sample
        );

        let mut token_stream: TokenStream = gpt4.generate(prompt).await?;
        let mut buffer = Vec::new();

        while let Some(token) = token_stream.next().await {
            println!("Token: {:?}", token);
            buffer.extend_from_slice(token.as_bytes());
        }

        let full_text = String::from_utf8(buffer)
            .map_err(|_| AsimovError::Output("Invalid UTF-8".to_string()))?;
        let deserialized: PythonCode = serde_json::from_str(&full_text)?;
        assert_eq!(deserialized, sample);

        println!("Deserialized PythonCode: {:?}", deserialized);

        Ok(())
    }

    #[derive(Serialize, Deserialize, Debug, Clone)]
    struct GenCellPlanStep {
        pub subgoal: String,
        pub consumes: Vec<String>,
        pub produces: String,
        pub tool_id: String,
    }
    #[tokio::test]
    async fn test_streamed_output() -> Result<()> {
        std::env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY must be set");

        let gpt4 = OpenAiLlm::builder().model("gpt-4".to_string()).build();

        let mut stream: StreamedOutput<GenCellPlanStep> =
        gpt4.generate("Return the following valid json verbatim: {'tool_id': 'python', 'consumes': [], 'subgoal': '1+1', 'produces': 'op1'} ").await.unwrap();

        while let Some(step) = stream.next().await {
            println!("Step: {:?}", step);
        }
        Ok(())
    }

    #[tokio::test]
    async fn test_llm_chain() -> Result<()> {
        std::env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY must be set");
        #[derive(Deserialize, Debug)]
        struct Sentiment {
            sentiment: bool,
        }

        // First LLM for sentiment analysis
        let sentiment_analysis_llm = OpenAiLlm::builder()
            .temperature(0.0)
            .model("gpt-3.5-turbo".to_string())
            .build();

        // Second LLM for summarizing sentiment
        let summarizing_llm = OpenAiLlm::builder()
            .model("gpt-3.5-turbo".to_string())
            .temperature(0.0)
            .build();

        let input = "The product is of high quality and the customer service is excellent.";

        let sentiment_prompt = prompt!(
            lines! {
                "Return the sentiment, true represents positive, false is negative.",
            "The output format should be like so: {\"sentiment\": true}",
            "Q: {{input}}\nA:" },
            input
        );

        let sentiment: Sentiment = sentiment_analysis_llm.generate(sentiment_prompt).await?;
        let sent: bool = sentiment.sentiment;
        assert_eq!(sent, true);

        let summary_prompt = prompt!(
            lines! {
                "The sentiment of the text {{input}} is {{sent}}.",
                "Summarize it"
            },
            input,
            sent
        );

        // Use the second LLM to summarize the sentiment
        let summary: RawString = summarizing_llm.generate(summary_prompt).await?;
        let tokenizer = OpenAiTiktoken::default();

        let encoded_summary = tokenizer.encode(&summary);
        println!("Generated {} tokens.", encoded_summary.len());

        assert!(encoded_summary.len() > 3);

        println!("Summary: {summary}");

        Ok(())
    }
}
